---
title: "Intermediate R"
output: html_document
---

#DataCamp
# TRACK/DATA ANALYST #

# INTERMEDIATE R
# https://www.datacamp.com/courses/intermediate-r 


#|##################|###########################################################################
#                              CHAPTER 1) CONDITIONALS AND CONTROL FLOW                       ##
#|##################|##########################################################################


```{r}
# RELATIONAL OPERATORS
#vídeo

TRUE == TRUE
TRUE == FALSE

"HELLO" == "GOODBYE"
"HELLO" != "GOODBYE"

3 < 5
3 > 5

"HELLO" == "GOODBYE"
#aparece TRUE porque est? ordenado por ordem alfab?tica

TURE < FALSE
#aparece FALSE porque 1 < 0 ? FALSE

3 >= 5

linkedin = c(16, 9, 3, 29)
linkedin > 10

facebook = c(4, 3, 9, 33)

facebook <= linkedin
```

#EXERCÍCIO 1
#EXERCÍCIO 2
```{r}
# Comparison of logicals
TRUE == FALSE

# Comparison of numerics
-6*14 != 17-101

# Comparison of character strings
"useR" == "user"

# Compare a logical with a numeric
TRUE == 1
FALSE == 0
```


#EXERCÍCIO 3
```{r}
# Comparison of numerics
-6*5+2 >= -10+1

# Comparison of character strings
"raining" <= "raining dogs" #sim devido à ordenação por ordem alfabética

# Comparison of logicals
TRUE > FALSE  #sim porque 1>0
```



#EXERCÍCIO 4
```{r}
# The linkedin and facebook vectors have already been created for you
linkedin <- c(16, 9, 13, 5, 2, 17, 14)
facebook <- c(17, 7, 5, 16, 8, 13, 14)

# Popular days
linkedin > 15

# Quiet days
linkedin <= 5

# LinkedIn more popular than Facebook
linkedin > facebook

###########teste meu
vetor_dias <- c("Segunda", "Terça", "Quarta", "Quinta", "Sexta", "S?bado", "Domingo")
facebook <- matrix(facebook, nrow = 1)
colnames(facebook) <- vetor_dias
row.names(facebook) <- "facebook"
facebook

```



#EXERCÍCIO 5
```{r}
#The social data has been created for you
linkedin <- c(16, 9, 13, 5, 2, 17, 14)
facebook <- c(17, 7, 5, 16, 8, 13, 14)
views <- matrix(c(linkedin, facebook), nrow = 2, byrow = TRUE)
rownames(views) <- c("linkedin", "facebook")
colnames(views) <- vetor_dias 
views

# When does views equal 13?
print("views equal 13")
views == 13

# When is views less than or equal to 14?
print("views less than or equal to 14")
views <= 14

```



#EXERCÍCIO 6
```{r}
#vídeo

# AND:&, 
# OR: |
# NOT: !

"AND"
# TRUE & TRUE == TRUE
# TRUE & FALSE == FALSE
# FALSE & TRUE == FALSE
# FALSE & FALSE == FALSE

"OR"
# TRUE | TRUE == TRUE
# TRUE | FALSE == TRUE
# FALSE | TRUE == TRUE
# FALSE | FALSE == FALSE

"NOT"
# !TRUE == FALSE
# !FALSE == TRUE

#LOGICAL OPERATORS AND VECTORS
# c(TRUE, TRUE, FALSE) & c(TRUE, FALSE, FALSE) == TRUE, FALSE, FALSE
# c(TRUE, TRUE, FALSE) | c(TRUE, FALSE, FALSE) == TRUE, TRUE, FALSE
# !c(TRUE, TRUE, FALSE) == FALSE, FALSE, TRUE



# & vs && 
# | vs ||

# c(TRUE, TRUE, FALSE) && c(TRUE, FALSE, FALSE) == TRUE     só analisa o primeiro resultado do vetor

# c(TRUE, TRUE, FALSE) || c(TRUE, FALSE, FALSE) == TRUE     só analisa o primeiro resultado do vetor

```




#EXERCÍCIO 7
```{r}
# The linkedin and last variable are already defined for you
linkedin <- c(16, 9, 13, 5, 2, 17, 14)
last <- tail(linkedin, 1)

# Is last under 5 or above 10?
last < 5 | last > 10

# Is last between 15 (exclusive) and 20 (inclusive)?
last > 15 & last <= 20
```



#EXERCÍCIO 8
```{r}
# The social data (linkedin, facebook, views) has been created for you
linkedin <- matrix(linkedin, nrow = 1, dimnames = list("linkedin", vetor_dias)) #ainda n tinha feito para o lk
#linkedin
#facebook
views

print("")
#fiz o print da matriz para n?o aparecer o nome lk na linha/row
# linkedin exceeds 10 but facebook below 10
matrix(linkedin > 10 & facebook <10, nrow = 1, dimnames = list("lk>10 & fb<10",vetor_dias)) 

#fiz o print da matriz para n?o aparecer o nome lk na linha/row
# When were one or both visited at least 12 times?
matrix(linkedin >= 12 | facebook >= 12, nrow = 1, dimnames = list("lk>=12 | fb >=12", vetor_dias))

print("")
#fiz o print da matriz de forma a aparecer com os dias nas colunas e "views" nas linhas/rowsS
# When is views between 11 (exclusive) and 14 (inclusive)?
matrix(views > 11 & views <= 14, nrow = 2, dimnames = list(c("views", "views"), vetor_dias))

```



#EXERCÍCIO 9
```{r}
# On top of the & and | operators, you also learned about the ! operator, which negates a logical value. To refresh your memory, here are some R expressions that use !. They all evaluate to FALSE:

# !TRUE
# !(5 > 3)
# !!FALSE
   
# What would the following set of R expressions return?
# x <- 5
# y <- 7
# !(!(x < 4) & !!!(y > 12))
 
# !(!FALSE & !!!FALSE)
# !(TRUE & !!TRUE )
# !(TRUE & !FALSE )
# !(TRUE & TRUE )
# !(TRUE)
# FALSE

#logo a resposta é: FALSE

```



#EXERCÍCIO 10
```{r}
# li_df is pre-loaded in your workspace - n?o est?, passei para texto(notepad), est? na pasta dropbox e importei o ficheiro
li_df  

# Select the second column (day2) from li_df and create a vector named second
second <- li_df[, 2]

# Build a logical vector, TRUE if value in second is extreme: extremes 
#i.e., Use second to create a logical vector, that contains TRUE if the corresponding number of views is strictly greater than 25 or strictly lower than 5 and FALSE otherwise. Store this logical vector as extremes]
extremes <- c(second > 25 | second < 5)
extremes

# Count the number of TRUEs in extremes
sum(extremes)

```




#EXERCÍCIO 11
```{r}
#vídeo

#teste meu
tlk <- 19

#if statements
if (tlk == 15)
  print("igual a 15 views") else
if (tlk<15) 
  print("menos de 15 views") else
  print("mais de 15 views")

#também podia ser com a condição elseif - ver à frente

```



#EXERCÍCIO 12
```{r}
# Variables related to your last day of recordings
medium <- "LinkedIn"
num_views <- 14

# Examine the if statement for medium
if (medium == "LinkedIn") 
  {print("Showing LinkedIn information")}
  
# Write the if statement for num_views
if (num_views > 15)
  print("You're popular!")

```



#EXERCÍCIO 13
```{r}
# Variables related to your last day of recordings
medium <- "LinkedIn"
num_views <- 14

#ver a utilização dos {}

# Control structure for medium
if (medium == "LinkedIn") {
  print("Showing LinkedIn information") 
} else
print("Unknown medium")


# Control structure for num_views
if (num_views > 15) 
  print("You're popular!") else
  print("Try to be more visible!")

```



#EXERCÍCIO 14
```{r}
# Variables related to your last day of recordings
medium <- "LinkedIn"
num_views <- 14

# Control structure for medium
if (medium == "LinkedIn") 
  print("Showing LinkedIn information") else if 
(medium == "Facebook") 
print("Showing Facebook information") else
  print("Unknown medium")


# Control structure for num_views
if (num_views > 15) {
  print("You're popular!")
} else if (num_views <= 15 & num_views > 10) {
print("Your number of views is average")
} else 
  print("Try to be more visible!")

#outra forma
num_views <- 14

if (num_views > 15)
  {
  print("You're popular!")
  } else if (num_views <= 15 & num_views > 10)
    {
    print("Your number of views is average")
    } else
      print("Try to be more visible!")



```



#EXERCÍCIO 15
```{r}

# Else if 2.0
 
numberx <- 102

if (numberx < 10) 
  {
  if (numberx < 5 ) 
    {
    print("extrasmall")
    } else 
      {
      print("small")
      }
  } else if (numberx < 100) 
    {
    print("medium")
    } else 
    {
    print("large")
    }


numbery <- 4

if (numbery < 10)
  if (numbery < 5 )
    print("extrasmall") else
      print("small") else if (numbery < 100)
        print("medium") else
          print("large")

numberz <- 23

if (numberz < 10) {
  if (numberz < 5) {
    print("extra-small")
  } else {
    print("small")
  } 
  } else if (numberz < 100) {
    print("medium")
  } else {
    print("large")
  }
    
# You can do anything you want inside if-else constructs. You can even put in another set of conditional statements. Examine the following code chunk:

# if (number < 10) {
#   if (number < 5) {
#     result <- "extra small"
#   } else {
#     result <- "small"
#   }
# } else if (number < 100) {
#   result <- "medium"
# } else {
#   result <- "large"
# }
# print(result)

# Have a look at the following statements:
# 
# If number is set to 6, "small" gets printed to the console.
# If number is set to 100, R prints out "medium".
# If number is set to 4, "extra small" gets printed out to the console.
# If number is set to 2500, R will generate an error, as result will not be defined.
# 
# Select the option that lists all the true statements.

#RESPOSTA: 1 and 3

```



#EXERCÍCIO 16
```{r}

  # Variables related to your last day of recordings
  li <- 15
  fb <- 9
  
  #COM OS {}
  
  # Code the control-flow construct
  if (li >= 15 & fb >= 15) {
    sms <- 2 * (li + fb)
  } else if (li < 10 & fb < 10) {
    sms <- 0.5 * (li + fb)
  } else {
    sms <- li + fb
  }
  
  # Print the resulting sms to the console
  sms
  
  
  #SEM OS {}
  if (li >= 15 & fb >= 15)
    sms <- 2* (li+fb) else if
  (li < 10 & fb < 10)
      sms <- 0.5 *(li+fb) else
        sms <- li+fb
  
  sms
  
```



#|##################|##############################################################################
#                                         CHAPTER 2) LOOPS
#|
#|##################|############################################################################


```{r}
# vídeo (exercício 1)

# while loop

contador <- 1

while (contador <= 7)
{
  print(paste("o contador continua a avançar e está em ", contador))
  contador <- contador + 1
}

#break
contador <- 1
while (contador <= 7)
{
  print(paste("o contador continua a avançar e está em ", contador))
  contador <- contador + 1
  if (contador == 5) {break}
}

```


#EXERCÍCIO 2
```{r}

# Initialize the speed variable
speed <- 64

# Code the while loop
while (speed > 30) 
{
print("Slow down!")
speed <- speed - 7
}

# Print out the speed variable
speed

```


#EXERCÍCIO 3
```{r}

# Initialize the speed variable
speed <- 64

# Extend/adapt the while loop
while (speed > 30) 
{
  print(paste("Your speed is",speed))
  if (speed > 48) 
  {
  print("Slow down big time!")  
  speed <- speed - 11 
  } else 
  {
  print("Slow down!")
  speed <- speed - 6
  }
}
speed

```


#EXERCÍCIO 4
```{r}

# Initialize the speed variable
speed <- 88

while (speed > 30) 
{
  print(paste("Your speed is", speed))
  
  # Break the while loop when speed exceeds 80
  if (speed > 80 ) {break}
  
  if (speed > 48) {
    print("Slow down big time!")
    speed <- speed - 11
  } else {
    print("Slow down!")
    speed <- speed - 6
  }
}
speed

```


#EXERCÍCIO 5
```{r}

# Initialize i as 1 
i <- 1

# Code the while loop
while (i <= 10) 
{
  print(i*3)
  if (3*i %% 8 == 0) {break}
  i <- i + 1
}

```


#EXERCÍCIO 6
```{r}
#vídeo
#for loop

cidades <- c("Porto", "Budapeste", "Ceuta", "Sydney", "Chicago", "Rio de Janeiro")

for (cidade in cidades)  #cidade é o nome que damos sabendo para identificar o que está no vetor
  {print(cidade)
}

#com listas é igual
cidades <- c("Porto", "Budapeste", "Ceuta", "Sydney", "Chicago", "Rio de Janeiro")
for (cidade in cidades)
  {print(cidade)
}
cidade

#com matrizes e data.frames (experimentar depois)


#break statement (pára quando o código lê o "break")
cities <- c("Porto", "Budapeste", "Ceuta", "Sydney", "Chicago", "Rio de Janeiro")

for (city in cities)   #mais uma vez, "city" foi o nome usado para identificar o que está no vetor
{
  if (nchar(city) == 6) {break}
  print(city)
} 
city

#next statement (salta as que cumprem o "break")
cities <- c("Porto", "Budapeste", "Ceuta", "Sydney", "Chicago", "Rio de Janeiro")

for (city in cities)
{
  if (nchar(city) == 6) {next}
  print(city)
} 


#for loop: v2
cidades <- c("Porto", "Budapeste", "Ceuta", "Sydney", "Chicago", "Rio de Janeiro")

for (i in 1:length(cidades))
{
  print(cidades[i])
}
#length(cidades) = 6 (número de variáveis)


#adicionar mais informação
for (i in 1:length(cidades))
{
  print(paste(cidades[i], "está na posição", i, "no vetor das cidades"))
}

```


#EXERCÍCIO 7
```{r}

# The linkedin vector has already been defined for you
linkedin <- c(16, 9, 13, 5, 2, 17, 14)

# Loop version 1
for (linkedin_views in linkedin)
{
  print(linkedin_views)
}
linkedin_views


# Loop version 2
for(i in 1:length(linkedin))
{
  print(paste("o número de views da",i, "página é", linkedin[i]))
}

```


#EXERCÍCIO 8
```{r}

# The nyc list is already specified
nyc <- list(pop = 8405837, 
            boroughs = c("Manhattan", "Bronx", "Brooklyn", "Queens", "Staten Island"), 
            capital = FALSE)

# Loop version 1
for (nyc.items.list in nyc)
{
  print(nyc.items.list)
}

# Loop version 2  -  para o loop versão 2 é necessário usar [[]] por se tratar de uma lista
for (i in 1:length(nyc))
{
  print(nyc[[i]])
}

```


#EXERCÍCIO 9
```{r}

ttt <- matrix(c("O", NA, "X", NA, "O", "O", "X", NA, "X"), nrow = 3, ncol = 3, byrow = TRUE)
ttt

#igual a colocar ttt <- matrix(c("O", NA, "X", NA, "O", "O", "X", NA, "X"), 3, 3, TRUE), pois o R lê por esta ordem ("Matching position") uma vez que assim o definiu (dados, nrow, ncol, byrow, ..)

matri
#meu
for (i in 1:ncol(ttt))
{
  for (j in 1:nrow(ttt))
  {
    if (i == 1) #só para meter if's no meio
    {
     print(paste("On the", i,"st column and ", j, "row is", ttt[j,i])) 
    } else if (i == 2)
    {
      print(paste("On the", i,"nd column and ", j, "row is", ttt[j,i]))
    } else if (i == 3)
    {
      print(paste("On the", i,"rd column and ", j, "row is", ttt[j,i]))
    }
  }
}
#meu

# The tic-tac-toe matrix ttt has already been defined for you

# define the double for loop
for (i in 1:nrow(ttt)) 
{
  for (j in 1:ncol(ttt))
  {
    print(paste("On row", i, "and column", j, "the board contains", ttt[i,j]))
  }
}


```


#EXERCÍCIO 10
```{r}
linkedin <- c(16, 9, 13, 5, 2, 17, 14)

# The linkedin vector has already been defined for you
linkedin <- c(16, 9, 13, 5, 2, 17, 14)

# Code the for loop with conditionals
for (li in linkedin) 
{
  if (li > 10)
  {
    print("You're popular!")
  } else 
  {
    print("Be more visible!")
  }
  print(li)
}


#meu 1
for (linkedin_views in linkedin)
{
  if (linkedin_views > 10)
  {
    print("You're popular")
  } else if (linkedin_views < 10)
  {
    print("Be more visible")
  }
}
linkedin_views

#meu 2
for (i in 1:length(linkedin))
{
  if (linkedin[i] > 10)
  {
    print(paste("regarding the",i, "profile you created, you're popular"))
  } else
  {
    print(paste("regarding the",i, "profile you created, you should try to be more visible"))
  }
}


```


#EXERCÍCIO 11
```{r}

# The linkedin vector has already been defined for you
linkedin <- c(16, 9, 13, 5, 2, 17, 14)

# Adapt/extend the for loop
for (li in linkedin) 
{
print(li)
  if (li > 16)
  {
    print("This is ridiculous, I'm outta here!")
    {break}
  }
  if (li < 5)
  {
    print("This is too embarrassing!")
    {next}
  }
  if (li > 10) 
  {
    print("You're popular!")
  } else 
  {
    print("Be more visible!")
  }
  }

```


#EXERCÍCIO 12
```{r}

rquote <- "r's internals are irrefutably intriguing"
chars <- strsplit(rquote, split = "")[[1]]

# Initialize rcount
rcount <- 0

# Finish the for loop
for (char in chars) 
{
  if (char == "u") {break}
  if (char == "r")
  {
    rcount <- rcount + 1
  }
}

# Print out rcount
print(rcount)

```



#|##################|###########################################################################
#                                         CHAPTER 3) FUNCTIONS
#|
#|##################|##########################################################################


#EXERCÍCIO 1
```{r}
#vídeo
#functions

#black box principle (para entender as funções):
# input -> "black box" -> output

#Function documentation: help(sd) ou ?sd, por exemplo, para entender o que está na função.

#o R lê por posição ("Matching by position") os argumentos que colocamos dentro da função, mas podemos sempre escrever noutra ordem, usando a descrição em si (e nesse caso lê por nome - "Matching by name"). Por exemplo: matrix(dados, ncol = 2, byrow = TRUE, nrows = 3) - que é diferente da posição definida pelo R ("Matching by name"). Os dois podem misturar-se acho eu

#na.rm - é um argumento lógico, refere-se a se os elementos que estão em falta devem ser removidos
#exemplo: 
#values <- c(1, 5, 6, NA)
#sd(values) produz o output NA uma vez que por default na.rm = FALSE

#nas funções, o R assume por posição, e por isso neste caso sd(values, TRUE) retira os NA



#Useful trick
#Utilizar a função "args" - para saber os argumentos da função e quais os defaults assumidos
args(sd)
args(matrix)

```


#EXERCÍCIO 2
```{r}

# Consult the documentation on the mean() function
?mean

# Inspect the arguments of the mean() function
args(mean)

```


#EXERCÍCIO 3
```{r}

# The linkedin and facebook vectors have already been created for you
linkedin <- c(16, 9, 13, 5, 2, 17, 14)
facebook <- c(17, 7, 5, 16, 8, 13, 14)

# Calculate average number of views
avg_li <- mean(linkedin)
avg_fb <- mean(facebook)

# Inspect avg_li and avg_fb
avg_li
avg_fb

```


#EXERCÍCIO 4
```{r}
##trim

# The linkedin and facebook vectors have already been created for you
linkedin <- c(16, 9, 13, 5, 2, 17, 14)
facebook <- c(17, 7, 5, 16, 8, 13, 14)

# Calculate the mean of the sum
avg_sum <- mean(linkedin+facebook)

# Calculate the trimmed mean of the sum
avg_sum_trimmed <- mean(linkedin+facebook, trim = 0.2)

# Inspect both new variables
avg_sum
avg_sum_trimmed

```


#EXERCÍCIO 5
```{r}
##na.rm

# The linkedin and facebook vectors have already been created for you
linkedin <- c(16, 9, 13, 5, NA, 17, 14)
facebook <- c(17, NA, 5, 16, 8, 13, 14)

# Basic average of linkedin
mean(linkedin)

# Advanced average of linkedin
mean(linkedin, na.rm = TRUE)

```


#EXERCÍCIO 6
```{r}

# The linkedin and facebook vectors have already been created for you
linkedin <- c(16, 9, 13, 5, NA, 17, 14)
facebook <- c(17, NA, 5, 16, 8, 13, 14)
max(linkedin)
# Calculate the mean absolute deviation
abs(linkedin-facebook)
mean(abs(linkedin-facebook), na.rm = TRUE)

```


#EXERCÍCIO 7
```{r}

# Which of the following statements about the read.table() function are true?

?read.table
args(read.table)

TRUE    # header, sep and quote are all optional arguments. 
FALSE   # row.names and fileEncoding don't have default values.
TRUE    # read.table("myfile.txt", "-", TRUE) will throw an error.
FALSE   # read.table("myfile.txt", sep = "-", header = TRUE) will throw an error.

```


#EXERCÍCIO 8
```{r}
##Writing Functions

#The triple() function
# my_fun <- function(arg1, arg2)
#  {body
#   }

triple <- function(x)
{
  3*x
}

triple(6)

#fazendo ls() aparece a função que utilizamos. Apaece tb no Golbal Environment na secção "Functions"


#meu
double.mais <- function(x, y = 0)
{
  2*x + y
}

double.mais(6)
double.mais(6, 2)


#------->  usar o return

# triple <- function(x)
# {
#   3*x
#   return(y)
# }
# 
# triple(6)


```


#EXERCÍCIO 9
```{r}

# Create a function pow_two()
pow_two <- function(x)
{
  x^2
}

# Use the function
pow_two(12)

# Create a function sum_abs()
sum_abs <- function(x,y)
{
  sum(abs(x)+abs(y))
}

# Use the function
sum_abs(-2,3)

```


#EXERCÍCIO 10
```{r}
#exemplo de funções que não necessitam de input
#1)
throw_die <- function() 
  {
  number <- sample(1:6, size = 1)
  number
  }

throw_die()

#2)

# Define the function hello()
hello <- function()
{
  print("Hi there!")
  TRUE
}


# Call the function hello()
hello()


```


#EXERCÍCIO 11
```{r}
?sd

# Finish the pow_two() function
pow_two <- function(x, print_info = TRUE) 
{
  y <- x ^ 2
  if (print_info == TRUE)
  {
  print(paste(x, "to the power two equals", y))
  }
  return(y)
}

pow_two(3)
pow_two(5)
pow_two(5, TRUE)

pow_two(5, FALSE) #aqui não vai imprimir a frase


```


#EXERCÍCIO 12
```{r}
# Function scoping. 
# Variables that are defined inside a function are not accessible outside that function. 
# 
# pow_two <- function(x) 
#   {
#   y <- x ^ 2
#   return(y)
#   }
# pow_two(4)
#
# y
# x
#
# y was defined inside the pow_two() function and therefore it is not accessible outside of that function. This is also true for the function's arguments of course - x in this case.


# Which statement is correct about the following chunk of code? The function two_dice() is already available in the workspace.

# two_dice <- function() 
#   {
#   possibilities <- 1:6
#   dice1 <- sample(possibilities, size = 1)
#   dice2 <- sample(possibilities, size = 1)
#   dice1 + dice2
#    }

# Possible Answers:

# (FALSE)   Executing two_dice() causes an error.
# (FALSE)   Executing res <- two_dice() makes the contents of dice1 and dice2 available outside the             function.
# (TRUE)    Whatever the way of calling the two_dice() function, R won't have access to dice1 and              dice2 outside the function.

```



#EXERCÍCIO 13
```{r}

# R passes arguments by value

# The title gives it away already: R passes arguments by value. What does this mean? Simply put, it means that an R function cannot change the variable that you input to that function. Let's look at a simple example (try it in the console):
 
triple <- function(x)
  {
  x <- 3*x
  x
  }
a <- 5
triple(a)
a

# Inside the triple() function, the argument x gets overwritten with its value times three. Afterwards this new x is returned. If you call this function with a variable a set equal to 5, you obtain 15. But did the value of a change? If R were to pass a to triple() by reference, the override of the x inside the function would ripple through to the variable a, outside the function. However, R passes by value, so the R objects you pass to a function can never change unless you do an explicit assignment. a remains equal to 5, even after calling triple(a).


# Can you tell which one of the following statements is false about the following piece of code?


increment <- function(x, inc = 1)
{
  x <- x + inc
  x
}

count <- 5
a <- increment(count, 2)
b <- increment(count)
count <- increment(count, 2)

# Possible Answers

# (TRUE)  a and b equal 7 and 6 respectively after executing this code block.
# (TRUE)  After the first call of increment(), where a is defined, a equals 7 and count equals 5.
# (FALSE) In the end, count will equal 10.
# In the last expression, the value of count was actually changed because of the explicit assignment.

```


#EXERCÍCIO 14
```{r}

# The linkedin and facebook vectors have already been created for you
linkedin
facebook

# Define the interpret function
interpret <- function(num_views) 
{
  if (num_views > 15) 
  {
  print("You're popular!")
  num_views
  } else 
  {
  print("Try to be more visible!")
  0
  }
}

# Call the interpret function twice
interpret(linkedin[1])
interpret(facebook[2])

```


#EXERCÍCIO 15
```{r}

# The linkedin and facebook vectors have already been created for you
linkedin <- c(16, 9, 13, 5, 2, 17, 14)
facebook <- c(17, 7, 5, 16, 8, 13, 14)

# The interpret() can be used inside interpret_all()
interpret <- function(num_views) 
{
  if (num_views > 15) 
  {
    print("You're popular!")
    return(num_views)
  } else 
  {
    print("Try to be more visible!")
    return(0)
  }
}


# Define the interpret_all() function
# views: vector with data to interpret
# return_sum: return total number of views on popular days?
interpret_all <- function(views, return_sum = TRUE) 
{
  countpop <- 0
  for (v in views) 
  {
  countpop <- interpret(v) + countpop
  }

  if (return_sum) 
  {
  countpop
  } else 
  {
  NULL
  }
}

# Call the interpret_all() function on both linkedin and facebook
interpret_all(linkedin)
interpret_all(facebook)

```


#EXERCÍCIO 16
```{r}
#vídeo
#R Packages
#install ggvis - para visualizações

#Load packages: require()

#library("data.table") ou library(data.table) não vai fazer o load se não estiver instalada
#install.package() instala

#require("data.table") ou require(data.table) vai dizer qual o package a instalar para ter acesso à função "data.table"

# search(), to look at the currently attached packages 

```


#EXERCÍCIO 17
```{r}

#Before starting, execute the following commands in the console:
search() # to look at the currently attached packages and
qplot(mtcars$wt, mtcars$hp) #to build a plot of two variables of the mtcars data frame.

# Load the ggplot2 package
library("ggplot2")

# Retry the qplot() function
qplot(mtcars$wt, mtcars$hp) #to build a plot of two variables of the mtcars data frame.

# Check out the currently attached packages again
search()

```


#EXERCÍCIO 18
```{r}

# Have a look at some more code chunks that (attempt to) load one or more packages:

# Chunk 1
# library(data.table)
# require(rjson)
# 
# Chunk 2
# library("data.table")
# require(rjson)
# 
# Chunk 3
# library(data.table)
# require(rjson, character.only = TRUE)
# 
# Chunk 4
# library(c("data.table", "rjson"))

# Select the option that lists all of the chunks that do not generate an error.
# (1) e (2) 

```




#|##################|###########################################################################
#                               CHAPTER 4) LAPPLY, SAPPLY and VAPPLY
#|
#|##################|##########################################################################


#EXERCÍCIO 1
```{r}
#vídeo
#lapply
#lapply(variável/vetor/lista, função)
#lapply(X, FUN, ...)
#lapply(vector or list X, applies the function FUN)

#lapply ALWAYS return a list, mas podemos usar o unlist()

# unlist(lapply(variável, função))

```


#EXERCÍCIO 2
```{r}

# The vector pioneers has already been created for you
pioneers <- c("GAUSS:1777", "BAYES:1702", "PASCAL:1623", "PEARSON:1857")

# Split names from birth year
split_math <- strsplit(pioneers, split = ":")
split_math

# Convert to lowercase strings: split_low
split_low <- lapply(split_math, tolower)

# Take a look at the structure of split_low
str(split_low)

```


#EXERCÍCIO 3
```{r}

# Code from previous exercise:
pioneers <- c("GAUSS:1777", "BAYES:1702", "PASCAL:1623", "PEARSON:1857")
split <- strsplit(pioneers, split = ":")
split_low <- lapply(split, tolower)

# Write function select_first()
select_first <- function(x) 
{
  x[1]
}

# Apply select_first() over split_low: names
names <- lapply(split_low, select_first)

# Write function select_second()
select_second <- function (x)
{
  x[2]
}


# Apply select_second() over split_low: years
years <- lapply(split_low, select_second)

names
years

```


#EXERCÍCIO 4
```{r}
#lapply and anonymous functions

# split_low has been created for you
split_low

# Transform: use anonymous function inside lapply
names <- lapply(split_low, function (x) { x[1] } )

# Transform: use anonymous function inside lapply
years <- lapply(split_low, function(x) { x[2] } )

names
years


```


#EXERCÍCIO 5
```{r}
#Para ficar generalizado (qual o elemento/índice do vetor a printar)

# Definition of split_low
pioneers <- c("GAUSS:1777", "BAYES:1702", "PASCAL:1623", "PEARSON:1857")
split <- strsplit(pioneers, split = ":")
split_low <- lapply(split, tolower)

# Generic select function
select_el <- function(x, index) 
{
  x[index]
}

# Use lapply() twice on split_low: names and years
names <- lapply(split_low, select_el, index = 1)
years <- lapply(split_low, select_el, index = 2)

```


#EXERCÍCIO 6
```{r}
#Apply functions that return NULL

lapply(list(1, "a", TRUE), str)
str(1)
str("a")
str(TRUE)
# This call actually returns a list, the same size as the input list, containing all NULL values. On the other hand calling str(TRUE) on its own prints only the structure of the logical to the console, not NULL. That's because str() uses invisible() behind the scenes, which returns an invisible copy of the return value, NULL in this case.

split_low

# What will the following code chunk return (split_low is already available in the workspace)? Try to reason about the result before simply executing it in the console!

lapply(split_low, function(x) 
  {
  if (nchar(x[1]) > 5) 
    {
    return(NULL)
    } else 
      {
      return(x[2])
      }
  })

#RESPOSTA: 
#list("1777", "1702", NULL, NULL)

```


#EXERCÍCIO 7
```{r}
#sapply
#simplified apply

#antigamente
lapply(cities, nchar)
unlist(lapply(cities, nchar))

#as usando o sapply é mais simples:
sapply(cities, nchar)
sapply(cities, nchar, USE.NAMES = FALSE) #USE.NAMES TRUE by default

```


#EXERCÍCIO 8
```{r}
# temp has already been defined in the workspace
temp <- list(c(3,7,9,6,-1),c(6,9,12,13,5), c(4,8,3,-1,-3), c(1,4,7,2,-2), c(5,7,9,4,2), c(-3,5,8,9,4), c(3,6,9,4,1))    
temp  

# Use lapply() to find each day's minimum temperature
lapply(temp, min)

# Use sapply() to find each day's minimum temperature
sapply(temp, min)

# Use lapply() to find each day's maximum temperature
lapply(temp, max)

# Use sapply() to find each day's maximum temperature
sapply(temp, max)

#lapply returns a list
#sapply return a vector that is a simplified version of the lapply list. In this case, the vector is not named (and USE.NAME is TRUE by default) - porque não tem nada para atribuir os valores da função exigida no lapply

```


#EXERCÍCIO 9
```{r}

# temp is already defined in the workspace

# Finish function definition of extremes_avg
extremes_avg <- function(x) 
{
  ( min(x) + max(x) ) / 2
}

# Apply extremes_avg() over temp using sapply()
sapply(temp, extremes_avg)

# Apply extremes_avg() over temp using lapply()
lapply(temp, extremes_avg)

#também podia ser, por exemplo para o sapply, usando uma função anónima:
sapply(temp, function(x) { (min(x) + max(x)) / 2 })
```


#EXERCÍCIO 10
```{r}
#sapply with function returning vector

# temp is already available in the workspace

# Create a function that returns min and max of a vector: extremes
extremes <- function(x) 
{
  c(min = min(x), max = max(x))
}

# Apply extremes() over temp with sapply()
sapply(temp, extremes)

# Apply extremes() over temp with lapply()
lapply(temp, extremes)

```


#EXERCÍCIO 11
```{r}

# temp is already prepared for you in the workspace

# Definition of below_zero()
below_zero <- function(x) 
{
  return(x[x < 0])
}

# Apply below_zero over temp using sapply(): freezing_s
freezing_s <- sapply(temp, below_zero)

# Apply below_zero over temp using lapply(): freezing_l
freezing_l <- lapply(temp, below_zero)


# Are freezing_s and freezing_l identical?
freezing_l
freezing_s
identical(freezing_s, freezing_l)

# Given that the length of the output of below_zero() changes for different input vectors, sapply() is not able to nicely convert the output of lapply() to a nicely formatted matrix. Instead, the output values of sapply() and lapply() are exactly the same, as shown by the TRUE output of identical().

```


#EXERCÍCIO 12
```{r}

# temp is already available in the workspace

# Definition of print_info()
print_info <- function(x) 
{
  cat("The average temperature is", mean(x), "\n")
}

# Apply print_info() over temp using sapply()
sapply(temp, print_info)

# Apply print_info() over temp using lapply()
lapply(temp, print_info)

# Notice here that, quite surprisingly, sapply() does not simplify the list of NULL's. That's because the 'vector-version' of a list of NULL's would simply be a NULL, which is no longer a vector with the same length as the input. 

```



#EXERCÍCIO 13
```{r}
#Reverse engineering sapply

sapply(list(runif(10), runif (10)), function(x) { c(min = min(x), mean = mean(x), max = max(x)) } )

#Without going straight to the console to run the code, try to reason through which of the following statements are correct and why.

# (1) sapply() can't simplify the result that lapply() would return, and thus returns a list of vectors.
# (2) This code generates a matrix with 3 rows and 2 columns.
# (3) The function that is used inside sapply() is anonymous.
# (4) The resulting data structure does not contain any names.

# RESPOSTA: 2 e 3

lapply(list(runif(10), runif (10)), function(x) { c(min = min(x), mean = mean(x), max = max(x)) } )
      
```


#EXERCÍCIO 14
```{r}
#vapply

```


#EXERCÍCIO 15
```{r}

# temp is already available in the workspace

# Definition of basics()
basics <- function(x) 
{
  c(min = min(x), mean = mean(x), max = max(x))
}

# Apply basics() over temp using vapply()
vapply(temp, basics, numeric(3))

```


#EXERCÍCIO 16
```{r}

# Definition of the basics() function
basics <- function(x) 
{
  c(min = min(x), mean = mean(x), median = median(x), max = max(x))
}

# Fix the error:
vapply(temp, basics, numeric(4)) #não dá se estiver numeric(3)

```


#EXERCÍCIO 17
```{r}

# temp is already defined in the workspace
temp
# Convert to vapply() expression
sapply(temp, max)
vapply(temp, max, numeric(1))

# Convert to vapply() expression
sapply(temp, function(x, y) { mean(x) > y }, y = 5)
vapply(temp, function(x, y) { mean(x) > y }, y = 5, logical(1))

```




#|##################|###############################################################################
#                                 CHAPTER 5) USEFUL FUNCTIONS
#|
#|##################|##############################################################################


#EXERCÍCIO 1
```{r}

# R features a bunch of functions to juggle around with data structures::
# 
# seq(): Generate sequences, by specifying the from, to, and by arguments.
# rep(): Replicate elements of vectors and lists.
# sort(): Sort a vector in ascending order. Works on numerics, but also on character strings and logicals.
# rev(): Reverse the elements in a data structures for which reversal is defined.
# str(): Display the structure of any R object.
# append(): Merge vectors or lists.
# is.*(): Check for the class of an R object.
# as.*(): Convert an R object from one class to another.
# unlist(): Flatten (possibly embedded) lists to produce a vector.

#...

```


#EXERCÍCIO 2
```{r}

# The errors vector has already been defined for you
errors <- c(1.9, -2.6, 4.0, -9.5, -3.4, 7.3)

# Sum of absolute rounded values of errors
sum(round(abs(errors)))

```


#EXERCÍCIO 3
```{r}

# Don't edit these two lines
vec1 <- c(1.5, 2.5, 8.4, 3.7, 6.3)
vec2 <- rev(vec1)
vec1
vec2

# Fix the error
#mean(abs(vec1), abs(vec2))
mean(c(abs(vec1), abs(vec2)))

```


#EXERCÍCIO 4
```{r}

# The linkedin and facebook lists have already been created for you
linkedin <- list(16, 9, 13, 5, 2, 17, 14)
facebook <- list(17, 7, 5, 16, 8, 13, 14)

# Convert linkedin and facebook to a vector: li_vec and fb_vec
li_vec <- unlist(linkedin)
fb_vec <- unlist(facebook)

li_vec
fb_vec

# Append fb_vec to li_vec: social_vec
social_vec <- append(li_vec, fb_vec)
social_vec

# Sort social_vec (decreasing)
sort(social_vec, decreasing = TRUE)

```


#EXERCÍCIO 5
```{r}
?seq
?rep

# Fix me
seq(rep(1, 7, by = 2), times = 7)

rep(seq(1, 7, by = 2), times = 7)

```


#EXERCÍCIO 6
```{r}

# Create first sequence: seq1
seq1 <- seq(1, 500, by = 3)

# Create second sequence: seq2
seq2 <- seq(1200, 900, by = -7)

# Calculate total sum of the sequences
sum(seq1, seq2)

```


#EXERCÍCIO 7
```{r}

#grepl() - para ver padrões
?regex

#grep - para saber em quais estão os padrões
#tb se pode escrever usando which(grepl())

#sub()  para substituir - (só vê/substitui o primeiro!)
#gsub()   substitui em todos

#pode usar-se argumentos lógicos em gsub, por exemplo "a|o" e replace = "_" - substitui as letras a e o

```


#EXERCÍCIO 8
```{r}
args(grepl)
args(grep)

# The emails vector has already been defined for you
emails <- c("john.doe@ivyleague.edu", "education@world.gov", "dalai.lama@peace.org",
            "invalid.edu", "quant@bigdatacollege.edu", "cookie.monster@sesame.tv")

# Use grepl() to match for "edu"
grepl(pattern = "edu", emails)

# Use grep() to match for "edu", save result to hits
hits <- grep(pattern = "edu", emails)
hits

# Subset emails using hits
emails[hits]

#queríamos ver os emails que terminavam em "edu" mas apareceram outros que tinham edu no meio (education@world.gov) 

```


#EXERCÍCIO 9
```{r}

# The emails vector has already been defined for you
emails <- c("john.doe@ivyleague.edu", "education@world.gov", "dalai.lama@peace.org",
            "invalid.edu", "quant@bigdatacollege.edu", "cookie.monster@sesame.tv")

# Use grepl() to match for .edu addresses more robustly
grepl(pattern = "@.*\\.edu$", emails)

# Use grep() to match for .edu addresses more robustly, save result to hits
hits <- grep(pattern = "@.*\\.edu$", emails)

# Subset emails using hits
emails[hits]

```


#EXERCÍCIO 10
```{r}
#sub() - replaces the first match; 
#gsub() - replaces all matches;

# The emails vector has already been defined for you
emails <- c("john.doe@ivyleague.edu", "education@world.gov", "global@peace.org",
            "invalid.edu", "quant@bigdatacollege.edu", "cookie.monster@sesame.tv")

# Use sub() to convert the email domains to datacamp.edu
sub(pattern = "@.*\\.edu$", replace = "@datacamp.edu", emails )


```


#EXERCÍCIO 11
```{r}

# Regular expressions are a typical concept that you'll learn by doing and by seeing other examples. Before you rack your brains over the regular expression in this exercise, have a look at the new things that will be used:
 
# .*: A usual suspect! It can be read as "any character that is matched zero or more times".
# \\s: Match a space. The "s" is normally a character, escaping it (\\) makes it a metacharacter.
# [0-9]+: Match the numbers 0 to 9, at least once (+).
# ([0-9]+): The parentheses are used to make parts of the matching string available to define the replacement. The \\1 in the replacement argument of sub() gets set to the string that is captured by the regular expression [0-9]+.

awards <- c("Won 1 Oscar.", "Won 1 Oscar. Another 9 wins & 24 nominations.", "1 win and 2 nominations.", "2 wins & 3 nominations.", "Nominated for 2 Golden Globes. 1 more win & 2 nominations.", "4 wins & 1 nomination.")
 
sub(".*\\s([0-9]+)\\snomination.*$", "\\1", awards)

# What does this code chunk return? 

# Possible Answers

# A vector of integers containing: 1, 24, 2, 3, 2, 1.
# The vector awards gets returned as there isn't a single element in awards that matches the regular expression.
# A vector of character strings containing "1", "24", "2", "3", "2", "1".
# A vector of character strings containing "Won 1 Oscar.", "24", "2", "3", "2", "1".


#RESPOSTA: A vector of character strings containing "Won 1 Oscar.", "24", "2", "3", "2", "1".

```


#EXERCÍCIO 12
```{r}
# Dates and times
today <- Sys.Date()
today
class(today) 

now <- Sys.time()
now
class(now) 
# "POSIXct" "POISXt"

my_date <- as.Date("1971-05-14")
my_date
class(my_date)

#Default format "%Y-%m-%d" (o nosso)
#my_date2 <- as.Date("1971-14-05")
#vai dar erro uma vez que o Default format é "%Y-%m-%d" (o nosso, "%Y-%m-%d")

my_date3 <- as.Date("1971-14-05", format ="%Y-%d-%m") #para pôr como no formato americano
my_date3
#podemos usar o nome dos meses,...


my_date
my_date+1 #+ 1 dia

my_date2 <- as.Date("1998-09-29")

my_date2 - my_date    #diferença de dias

#POSIXct arithmetic
now
now + 1 #second increased by 1



#Under the hood
my_date

unclass(my_date) #498 days from january 1, 1970

#Dedicated R packages
#lubridate
#zoo
#xts

```



#EXERCÍCIO 13
```{r}

# In R, dates are represented by Date objects, while times are represented by POSIXct objects. Under the hood, however, these dates and times are simple numerical values. Date objects store the number of days since the 1st of January in 1970. POSIXct objects on the other hand, store the number of seconds since the 1st of January in 1970.

# The 1st of January in 1970 is the common origin for representing times and dates in a wide range of programming languages. There is no particular reason for this; it is a simple convention. Of course, it's also possible to create dates and times before 1970; the corresponding numerical values are simply negative in this case.

# Get the current date: today
today <- Sys.Date()

# See what today looks like under the hood
unclass(today)

# Get the current time: now
now <- Sys.time()

# See what now looks like under the hood
unclass(now)

```


#EXERCÍCIO 14
```{r}
# %Y: 4-digit year (1982)
# %y: 2-digit year (82)
# %m: 2-digit month (01)
# %d: 2-digit day of the month (13)
# %A: weekday (Wednesday)
# %a: abbreviated weekday (Wed)
# %B: month (January)
# %b: abbreviated month (Jan)

#exemplo com a função format()
today <- Sys.Date()
format(Sys.Date(), format = "%d %B, %Y")
format(Sys.Date(), format = "Today is a %A!")

# Definition of character strings representing dates
str1 <- "May 23, '96"
str2 <- "2012-03-15"
str3 <- "30/January/2006"

# Convert the strings to dates: date1, date2, date3
date1 <- as.Date(str1, format = "%b %d, '%y")
date2 <- as.Date(str2)
date3 <- as.Date(str3, format = "%d/%B/%Y")


# Convert dates to formatted strings
format(date1, "%A")
format(date2, "%d")
format(date3, "%b %Y")


```


#EXERCÍCIO 15
```{r}

# %H: hours as a decimal number (00-23)
# %I: hours as a decimal number (01-12)
# %M: minutes as a decimal number
# %S: seconds as a decimal number
# %T: shorthand notation for the typical format %H:%M:%S
# %p: AM/PM indicator

# Definition of character strings representing times
str1 <- "May 23, '96 hours:23 minutes:01 seconds:45"
str2 <- "2012-3-12 14:23:08"

# Convert the strings to POSIXct objects: time1, time2
time1 <- as.POSIXct(str1, format = "%B %d, '%y hours:%H minutes:%M seconds:%S")
time2 <- as.POSIXct(str2, format = "%Y-%m-%d %T")


# Convert times to formatted strings
format(time1, "%M")
format(time2, "%I:%M %p")

```


#EXERCÍCIO 16
```{r}

# day1, day2, day3, day4 and day5 are already available in the workspace
day1 <- as.Date("2018-11-24")
day2 <- as.Date("2018-11-26")
day3 <- as.Date("2018-12-01")
day4 <- as.Date("2018-12-07")
day5 <- as.Date("2018-12-07")

# Difference between last and first pizza day
day5 - day1

# Create vector pizza
pizza <- c(day1, day2, day3, day4, day5)
pizza

# Create differences between consecutive pizza days: day_diff
day_diff <- diff(pizza)
day_diff

# Average period between two consecutive pizza days
mean(day_diff)

```


#EXERCÍCIO 17
```{r}

now <- Sys.time()
now
now + 3600          # add an hour
now - 3600 * 24     # subtract a day

birth <- as.POSIXct("1879-03-14 14:37:23")
death <- as.POSIXct("1955-04-18 03:47:12")
einstein <- death - birth
einstein

#Exercício

# login and logout are already defined in the workspace
login <- c(as.POSIXct("2018-11-28 10:18:04 UTC"), as.POSIXct("2018-12-03 09:14:18 UTC"), as.POSIXct("2018-12-03 09:14:18 UTC"), as.POSIXct("2018-12-03 12:37:24 UTC"), as.POSIXct("2018-12-05 21:37:55 UTC"))

logout <- c(as.POSIXct("2018-11-28 10:56:29 UTC"), as.POSIXct("2018-12-03 09:14:52 UTC"), as.POSIXct("2018-12-03 12:35:48 UTC"), as.POSIXct("2018-12-03 12:35:48 UTC"), as.POSIXct("2018-12-03 12:35:48 UTC"))

login
logout

# Calculate the difference between login and logout: time_online
time_online <- logout - login

# Inspect the variable time_online
time_online

# Calculate the total time online
sum(time_online)

# Calculate the average time online
mean(time_online)


```


#EXERCÍCIO 18
```{r}

#astro - falta definir
# meteo - falta definir

# Convert astro to vector of Date objects: astro_dates
astro_dates <- as.Date(astro, format = "%d-%b-%Y")
astro_dates

# Convert meteo to vector of Date objects: meteo_dates
meteo_dates <- as.Date(meteo, format = "%B %d, %y")
meteo_dates

# Calculate the maximum absolute difference between astro_dates and meteo_dates
max(abs(astro_dates - meteo_dates))


```


# FIM





